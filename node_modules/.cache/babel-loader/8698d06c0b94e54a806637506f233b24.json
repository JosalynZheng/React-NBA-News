{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AtomicBlockUtils\n * @typechecks\n * \n */\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\n\nvar CharacterMetadata = require('./CharacterMetadata');\n\nvar ContentBlock = require('./ContentBlock');\n\nvar DraftModifier = require('./DraftModifier');\n\nvar EditorState = require('./EditorState');\n\nvar Immutable = require('immutable');\n\nvar SelectionState = require('./SelectionState');\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar moveBlockInContentState = require('./moveBlockInContentState');\n\nvar List = Immutable.List,\n    Repeat = Immutable.Repeat;\nvar AtomicBlockUtils = {\n  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n    var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');\n    var targetSelection = afterRemoval.getSelectionAfter();\n    var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);\n    var insertionTarget = afterSplit.getSelectionAfter();\n    var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');\n    var charData = CharacterMetadata.create({\n      entity: entityKey\n    });\n    var fragmentArray = [new ContentBlock({\n      key: generateRandomKey(),\n      type: 'atomic',\n      text: character,\n      characterList: List(Repeat(charData, character.length))\n    }), new ContentBlock({\n      key: generateRandomKey(),\n      type: 'unstyled',\n      text: '',\n      characterList: List()\n    })];\n    var fragment = BlockMapBuilder.createFromArray(fragmentArray);\n    var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);\n    var newContent = withAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n    return EditorState.push(editorState, newContent, 'insert-fragment');\n  },\n  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n    var withMovedAtomicBlock = void 0;\n\n    if (insertionMode === 'before' || insertionMode === 'after') {\n      var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());\n      withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);\n    } else {\n      var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');\n      var selectionAfterRemoval = afterRemoval.getSelectionAfter();\n\n      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());\n\n      if (selectionAfterRemoval.getStartOffset() === 0) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');\n      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');\n      } else {\n        var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);\n        var selectionAfterSplit = afterSplit.getSelectionAfter();\n\n        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());\n\n        withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');\n      }\n    }\n\n    var newContent = withMovedAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n    return EditorState.push(editorState, newContent, 'move-block');\n  }\n};\nmodule.exports = AtomicBlockUtils;","map":{"version":3,"sources":["/Users/zhengjie/Documents/Fulltime/nba_app/node_modules/draft-js/lib/AtomicBlockUtils.js"],"names":["BlockMapBuilder","require","CharacterMetadata","ContentBlock","DraftModifier","EditorState","Immutable","SelectionState","generateRandomKey","moveBlockInContentState","List","Repeat","AtomicBlockUtils","insertAtomicBlock","editorState","entityKey","character","contentState","getCurrentContent","selectionState","getSelection","afterRemoval","removeRange","targetSelection","getSelectionAfter","afterSplit","splitBlock","insertionTarget","asAtomicBlock","setBlockType","charData","create","entity","fragmentArray","key","type","text","characterList","length","fragment","createFromArray","withAtomicBlock","replaceWithFragment","newContent","merge","selectionBefore","selectionAfter","set","push","moveAtomicBlock","atomicBlock","targetRange","insertionMode","withMovedAtomicBlock","targetBlock","getBlockForKey","getStartKey","getEndKey","selectionAfterRemoval","_targetBlock","getFocusKey","getStartOffset","getEndOffset","getLength","selectionAfterSplit","_targetBlock2","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule AtomicBlockUtils\n * @typechecks\n * \n */\n\n'use strict';\n\nvar BlockMapBuilder = require('./BlockMapBuilder');\nvar CharacterMetadata = require('./CharacterMetadata');\nvar ContentBlock = require('./ContentBlock');\nvar DraftModifier = require('./DraftModifier');\nvar EditorState = require('./EditorState');\nvar Immutable = require('immutable');\nvar SelectionState = require('./SelectionState');\n\nvar generateRandomKey = require('./generateRandomKey');\nvar moveBlockInContentState = require('./moveBlockInContentState');\n\nvar List = Immutable.List,\n    Repeat = Immutable.Repeat;\n\n\nvar AtomicBlockUtils = {\n  insertAtomicBlock: function insertAtomicBlock(editorState, entityKey, character) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n\n    var afterRemoval = DraftModifier.removeRange(contentState, selectionState, 'backward');\n\n    var targetSelection = afterRemoval.getSelectionAfter();\n    var afterSplit = DraftModifier.splitBlock(afterRemoval, targetSelection);\n    var insertionTarget = afterSplit.getSelectionAfter();\n\n    var asAtomicBlock = DraftModifier.setBlockType(afterSplit, insertionTarget, 'atomic');\n\n    var charData = CharacterMetadata.create({ entity: entityKey });\n\n    var fragmentArray = [new ContentBlock({\n      key: generateRandomKey(),\n      type: 'atomic',\n      text: character,\n      characterList: List(Repeat(charData, character.length))\n    }), new ContentBlock({\n      key: generateRandomKey(),\n      type: 'unstyled',\n      text: '',\n      characterList: List()\n    })];\n\n    var fragment = BlockMapBuilder.createFromArray(fragmentArray);\n\n    var withAtomicBlock = DraftModifier.replaceWithFragment(asAtomicBlock, insertionTarget, fragment);\n\n    var newContent = withAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n\n    return EditorState.push(editorState, newContent, 'insert-fragment');\n  },\n\n  moveAtomicBlock: function moveAtomicBlock(editorState, atomicBlock, targetRange, insertionMode) {\n    var contentState = editorState.getCurrentContent();\n    var selectionState = editorState.getSelection();\n\n    var withMovedAtomicBlock = void 0;\n\n    if (insertionMode === 'before' || insertionMode === 'after') {\n      var targetBlock = contentState.getBlockForKey(insertionMode === 'before' ? targetRange.getStartKey() : targetRange.getEndKey());\n\n      withMovedAtomicBlock = moveBlockInContentState(contentState, atomicBlock, targetBlock, insertionMode);\n    } else {\n      var afterRemoval = DraftModifier.removeRange(contentState, targetRange, 'backward');\n\n      var selectionAfterRemoval = afterRemoval.getSelectionAfter();\n      var _targetBlock = afterRemoval.getBlockForKey(selectionAfterRemoval.getFocusKey());\n\n      if (selectionAfterRemoval.getStartOffset() === 0) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'before');\n      } else if (selectionAfterRemoval.getEndOffset() === _targetBlock.getLength()) {\n        withMovedAtomicBlock = moveBlockInContentState(afterRemoval, atomicBlock, _targetBlock, 'after');\n      } else {\n        var afterSplit = DraftModifier.splitBlock(afterRemoval, selectionAfterRemoval);\n\n        var selectionAfterSplit = afterSplit.getSelectionAfter();\n        var _targetBlock2 = afterSplit.getBlockForKey(selectionAfterSplit.getFocusKey());\n\n        withMovedAtomicBlock = moveBlockInContentState(afterSplit, atomicBlock, _targetBlock2, 'before');\n      }\n    }\n\n    var newContent = withMovedAtomicBlock.merge({\n      selectionBefore: selectionState,\n      selectionAfter: withMovedAtomicBlock.getSelectionAfter().set('hasFocus', true)\n    });\n\n    return EditorState.push(editorState, newContent, 'move-block');\n  }\n};\n\nmodule.exports = AtomicBlockUtils;"]},"metadata":{},"sourceType":"script"}