{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getContentStateFragment\n * @typechecks\n * \n */\n'use strict';\n\nvar generateRandomKey = require('./generateRandomKey');\n\nvar removeEntitiesAtEdges = require('./removeEntitiesAtEdges');\n\nfunction getContentStateFragment(contentState, selectionState) {\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset(); // Edge entities should be stripped to ensure that we don't preserve\n  // invalid partial entities when the fragment is reused. We do, however,\n  // preserve entities that are entirely within the selection range.\n\n  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);\n  var blockMap = contentWithoutEdgeEntities.getBlockMap();\n  var blockKeys = blockMap.keySeq();\n  var startIndex = blockKeys.indexOf(startKey);\n  var endIndex = blockKeys.indexOf(endKey) + 1;\n  var slice = blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {\n    var newKey = generateRandomKey();\n    var text = block.getText();\n    var chars = block.getCharacterList();\n\n    if (startKey === endKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(startOffset, endOffset),\n        characterList: chars.slice(startOffset, endOffset)\n      });\n    }\n\n    if (blockKey === startKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(startOffset),\n        characterList: chars.slice(startOffset)\n      });\n    }\n\n    if (blockKey === endKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(0, endOffset),\n        characterList: chars.slice(0, endOffset)\n      });\n    }\n\n    return block.set('key', newKey);\n  });\n  return slice.toOrderedMap();\n}\n\nmodule.exports = getContentStateFragment;","map":{"version":3,"sources":["/Users/zhengjie/Documents/Fulltime/nba_app/node_modules/draft-js/lib/getContentStateFragment.js"],"names":["generateRandomKey","require","removeEntitiesAtEdges","getContentStateFragment","contentState","selectionState","startKey","getStartKey","startOffset","getStartOffset","endKey","getEndKey","endOffset","getEndOffset","contentWithoutEdgeEntities","blockMap","getBlockMap","blockKeys","keySeq","startIndex","indexOf","endIndex","slice","map","block","blockKey","newKey","text","getText","chars","getCharacterList","merge","key","characterList","set","toOrderedMap","module","exports"],"mappings":"AAAA;;;;;;;;;;;;AAaA;;AAEA,IAAIA,iBAAiB,GAAGC,OAAO,CAAC,qBAAD,CAA/B;;AACA,IAAIC,qBAAqB,GAAGD,OAAO,CAAC,yBAAD,CAAnC;;AAEA,SAASE,uBAAT,CAAiCC,YAAjC,EAA+CC,cAA/C,EAA+D;AAC7D,MAAIC,QAAQ,GAAGD,cAAc,CAACE,WAAf,EAAf;AACA,MAAIC,WAAW,GAAGH,cAAc,CAACI,cAAf,EAAlB;AACA,MAAIC,MAAM,GAAGL,cAAc,CAACM,SAAf,EAAb;AACA,MAAIC,SAAS,GAAGP,cAAc,CAACQ,YAAf,EAAhB,CAJ6D,CAM7D;AACA;AACA;;AACA,MAAIC,0BAA0B,GAAGZ,qBAAqB,CAACE,YAAD,EAAeC,cAAf,CAAtD;AAEA,MAAIU,QAAQ,GAAGD,0BAA0B,CAACE,WAA3B,EAAf;AACA,MAAIC,SAAS,GAAGF,QAAQ,CAACG,MAAT,EAAhB;AACA,MAAIC,UAAU,GAAGF,SAAS,CAACG,OAAV,CAAkBd,QAAlB,CAAjB;AACA,MAAIe,QAAQ,GAAGJ,SAAS,CAACG,OAAV,CAAkBV,MAAlB,IAA4B,CAA3C;AAEA,MAAIY,KAAK,GAAGP,QAAQ,CAACO,KAAT,CAAeH,UAAf,EAA2BE,QAA3B,EAAqCE,GAArC,CAAyC,UAAUC,KAAV,EAAiBC,QAAjB,EAA2B;AAC9E,QAAIC,MAAM,GAAG1B,iBAAiB,EAA9B;AAEA,QAAI2B,IAAI,GAAGH,KAAK,CAACI,OAAN,EAAX;AACA,QAAIC,KAAK,GAAGL,KAAK,CAACM,gBAAN,EAAZ;;AAEA,QAAIxB,QAAQ,KAAKI,MAAjB,EAAyB;AACvB,aAAOc,KAAK,CAACO,KAAN,CAAY;AACjBC,QAAAA,GAAG,EAAEN,MADY;AAEjBC,QAAAA,IAAI,EAAEA,IAAI,CAACL,KAAL,CAAWd,WAAX,EAAwBI,SAAxB,CAFW;AAGjBqB,QAAAA,aAAa,EAAEJ,KAAK,CAACP,KAAN,CAAYd,WAAZ,EAAyBI,SAAzB;AAHE,OAAZ,CAAP;AAKD;;AAED,QAAIa,QAAQ,KAAKnB,QAAjB,EAA2B;AACzB,aAAOkB,KAAK,CAACO,KAAN,CAAY;AACjBC,QAAAA,GAAG,EAAEN,MADY;AAEjBC,QAAAA,IAAI,EAAEA,IAAI,CAACL,KAAL,CAAWd,WAAX,CAFW;AAGjByB,QAAAA,aAAa,EAAEJ,KAAK,CAACP,KAAN,CAAYd,WAAZ;AAHE,OAAZ,CAAP;AAKD;;AAED,QAAIiB,QAAQ,KAAKf,MAAjB,EAAyB;AACvB,aAAOc,KAAK,CAACO,KAAN,CAAY;AACjBC,QAAAA,GAAG,EAAEN,MADY;AAEjBC,QAAAA,IAAI,EAAEA,IAAI,CAACL,KAAL,CAAW,CAAX,EAAcV,SAAd,CAFW;AAGjBqB,QAAAA,aAAa,EAAEJ,KAAK,CAACP,KAAN,CAAY,CAAZ,EAAeV,SAAf;AAHE,OAAZ,CAAP;AAKD;;AAED,WAAOY,KAAK,CAACU,GAAN,CAAU,KAAV,EAAiBR,MAAjB,CAAP;AACD,GA/BW,CAAZ;AAiCA,SAAOJ,KAAK,CAACa,YAAN,EAAP;AACD;;AAEDC,MAAM,CAACC,OAAP,GAAiBlC,uBAAjB","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule getContentStateFragment\n * @typechecks\n * \n */\n\n'use strict';\n\nvar generateRandomKey = require('./generateRandomKey');\nvar removeEntitiesAtEdges = require('./removeEntitiesAtEdges');\n\nfunction getContentStateFragment(contentState, selectionState) {\n  var startKey = selectionState.getStartKey();\n  var startOffset = selectionState.getStartOffset();\n  var endKey = selectionState.getEndKey();\n  var endOffset = selectionState.getEndOffset();\n\n  // Edge entities should be stripped to ensure that we don't preserve\n  // invalid partial entities when the fragment is reused. We do, however,\n  // preserve entities that are entirely within the selection range.\n  var contentWithoutEdgeEntities = removeEntitiesAtEdges(contentState, selectionState);\n\n  var blockMap = contentWithoutEdgeEntities.getBlockMap();\n  var blockKeys = blockMap.keySeq();\n  var startIndex = blockKeys.indexOf(startKey);\n  var endIndex = blockKeys.indexOf(endKey) + 1;\n\n  var slice = blockMap.slice(startIndex, endIndex).map(function (block, blockKey) {\n    var newKey = generateRandomKey();\n\n    var text = block.getText();\n    var chars = block.getCharacterList();\n\n    if (startKey === endKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(startOffset, endOffset),\n        characterList: chars.slice(startOffset, endOffset)\n      });\n    }\n\n    if (blockKey === startKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(startOffset),\n        characterList: chars.slice(startOffset)\n      });\n    }\n\n    if (blockKey === endKey) {\n      return block.merge({\n        key: newKey,\n        text: text.slice(0, endOffset),\n        characterList: chars.slice(0, endOffset)\n      });\n    }\n\n    return block.set('key', newKey);\n  });\n\n  return slice.toOrderedMap();\n}\n\nmodule.exports = getContentStateFragment;"]},"metadata":{},"sourceType":"script"}