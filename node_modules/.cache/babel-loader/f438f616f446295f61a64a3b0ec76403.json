{"ast":null,"code":"/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DraftEditorCompositionHandler\n * \n */\n'use strict';\n\nvar DraftModifier = require('./DraftModifier');\n\nvar EditorState = require('./EditorState');\n\nvar Keys = require('fbjs/lib/Keys');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\n\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\n/**\n * Millisecond delay to allow `compositionstart` to fire again upon\n * `compositionend`.\n *\n * This is used for Korean input to ensure that typing can continue without\n * the editor trying to render too quickly. More specifically, Safari 7.1+\n * triggers `compositionstart` a little slower than Chrome/FF, which\n * leads to composed characters being resolved and re-render occurring\n * sooner than we want.\n */\n\n\nvar RESOLVE_DELAY = 20;\n/**\n * A handful of variables used to track the current composition and its\n * resolution status. These exist at the module level because it is not\n * possible to have compositions occurring in multiple editors simultaneously,\n * and it simplifies state management with respect to the DraftEditor component.\n */\n\nvar resolved = false;\nvar stillComposing = false;\nvar textInputData = '';\nvar DraftEditorCompositionHandler = {\n  onBeforeInput: function onBeforeInput(editor, e) {\n    textInputData = (textInputData || '') + e.data;\n  },\n\n  /**\n   * A `compositionstart` event has fired while we're still in composition\n   * mode. Continue the current composition session to prevent a re-render.\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n  },\n\n  /**\n   * Attempt to end the current composition session.\n   *\n   * Defer handling because browser will still insert the chars into active\n   * element after `compositionend`. If a `compositionstart` event fires\n   * before `resolveComposition` executes, our composition session will\n   * continue.\n   *\n   * The `resolved` flag is useful because certain IME interfaces fire the\n   * `compositionend` event multiple times, thus queueing up multiple attempts\n   * at handling the composition. Since handling the same composition event\n   * twice could break the DOM, we only use the first event. Example: Arabic\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n\n  /**\n   * In Safari, keydown events may fire when committing compositions. If\n   * the arrow keys are used to commit, prevent default so that the cursor\n   * doesn't move, otherwise it will jump back noticeably on re-render.\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n\n      editor._onKeyDown(e);\n\n      return;\n    }\n\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Keypress events may fire when committing compositions. In Firefox,\n   * pressing RETURN commits the composition and inserts extra newline\n   * characters that we do not want. `preventDefault` allows the composition\n   * to be committed while preventing the extra characters.\n   */\n  onKeyPress: function onKeyPress(editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Attempt to insert composed characters into the document.\n   *\n   * If we are still in a composition session, do nothing. Otherwise, insert\n   * the characters into the document and terminate the composition session.\n   *\n   * If no characters were composed -- for instance, the user\n   * deleted all composed characters and committed nothing new --\n   * force a re-render. We also re-render when the composition occurs\n   * at the beginning of a leaf, to ensure that if the browser has\n   * created a new text node for the composition, we will discard it.\n   *\n   * Resetting innerHTML will move focus to the beginning of the editor,\n   * so we update to force it back to the correct place.\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n\n    resolved = true;\n    var composedChars = textInputData;\n    textInputData = '';\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\n\n    if (mustReset) {\n      editor.restoreEditorDOM();\n    }\n\n    editor.exitCurrentMode();\n\n    if (composedChars) {\n      // If characters have been composed, re-rendering with the update\n      // is sufficient to reset the editor.\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\n      return;\n    }\n\n    if (mustReset) {\n      editor.update(EditorState.set(editorState, {\n        nativelyRenderedContent: null,\n        forceSelection: true\n      }));\n    }\n  }\n};\nmodule.exports = DraftEditorCompositionHandler;","map":{"version":3,"sources":["/Users/zhengjie/Documents/Fulltime/nba_app/node_modules/draft-js/lib/DraftEditorCompositionHandler.js"],"names":["DraftModifier","require","EditorState","Keys","getEntityKeyForSelection","isSelectionAtLeafStart","RESOLVE_DELAY","resolved","stillComposing","textInputData","DraftEditorCompositionHandler","onBeforeInput","editor","e","data","onCompositionStart","onCompositionEnd","setTimeout","resolveComposition","onKeyDown","_onKeyDown","which","RIGHT","LEFT","preventDefault","onKeyPress","RETURN","composedChars","editorState","set","_latestEditorState","inCompositionMode","currentStyle","getCurrentInlineStyle","entityKey","getCurrentContent","getSelection","mustReset","size","restoreEditorDOM","exitCurrentMode","contentState","replaceText","update","push","nativelyRenderedContent","forceSelection","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) 2013-present, Facebook, Inc.\n * All rights reserved.\n *\n * This source code is licensed under the BSD-style license found in the\n * LICENSE file in the root directory of this source tree. An additional grant\n * of patent rights can be found in the PATENTS file in the same directory.\n *\n * @providesModule DraftEditorCompositionHandler\n * \n */\n\n'use strict';\n\nvar DraftModifier = require('./DraftModifier');\nvar EditorState = require('./EditorState');\nvar Keys = require('fbjs/lib/Keys');\n\nvar getEntityKeyForSelection = require('./getEntityKeyForSelection');\nvar isSelectionAtLeafStart = require('./isSelectionAtLeafStart');\n\n/**\n * Millisecond delay to allow `compositionstart` to fire again upon\n * `compositionend`.\n *\n * This is used for Korean input to ensure that typing can continue without\n * the editor trying to render too quickly. More specifically, Safari 7.1+\n * triggers `compositionstart` a little slower than Chrome/FF, which\n * leads to composed characters being resolved and re-render occurring\n * sooner than we want.\n */\nvar RESOLVE_DELAY = 20;\n\n/**\n * A handful of variables used to track the current composition and its\n * resolution status. These exist at the module level because it is not\n * possible to have compositions occurring in multiple editors simultaneously,\n * and it simplifies state management with respect to the DraftEditor component.\n */\nvar resolved = false;\nvar stillComposing = false;\nvar textInputData = '';\n\nvar DraftEditorCompositionHandler = {\n  onBeforeInput: function onBeforeInput(editor, e) {\n    textInputData = (textInputData || '') + e.data;\n  },\n\n  /**\n   * A `compositionstart` event has fired while we're still in composition\n   * mode. Continue the current composition session to prevent a re-render.\n   */\n  onCompositionStart: function onCompositionStart(editor) {\n    stillComposing = true;\n  },\n\n  /**\n   * Attempt to end the current composition session.\n   *\n   * Defer handling because browser will still insert the chars into active\n   * element after `compositionend`. If a `compositionstart` event fires\n   * before `resolveComposition` executes, our composition session will\n   * continue.\n   *\n   * The `resolved` flag is useful because certain IME interfaces fire the\n   * `compositionend` event multiple times, thus queueing up multiple attempts\n   * at handling the composition. Since handling the same composition event\n   * twice could break the DOM, we only use the first event. Example: Arabic\n   * Google Input Tools on Windows 8.1 fires `compositionend` three times.\n   */\n  onCompositionEnd: function onCompositionEnd(editor) {\n    resolved = false;\n    stillComposing = false;\n    setTimeout(function () {\n      if (!resolved) {\n        DraftEditorCompositionHandler.resolveComposition(editor);\n      }\n    }, RESOLVE_DELAY);\n  },\n\n  /**\n   * In Safari, keydown events may fire when committing compositions. If\n   * the arrow keys are used to commit, prevent default so that the cursor\n   * doesn't move, otherwise it will jump back noticeably on re-render.\n   */\n  onKeyDown: function onKeyDown(editor, e) {\n    if (!stillComposing) {\n      // If a keydown event is received after compositionend but before the\n      // 20ms timer expires (ex: type option-E then backspace, or type A then\n      // backspace in 2-Set Korean), we should immediately resolve the\n      // composition and reinterpret the key press in edit mode.\n      DraftEditorCompositionHandler.resolveComposition(editor);\n      editor._onKeyDown(e);\n      return;\n    }\n    if (e.which === Keys.RIGHT || e.which === Keys.LEFT) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Keypress events may fire when committing compositions. In Firefox,\n   * pressing RETURN commits the composition and inserts extra newline\n   * characters that we do not want. `preventDefault` allows the composition\n   * to be committed while preventing the extra characters.\n   */\n  onKeyPress: function onKeyPress(editor, e) {\n    if (e.which === Keys.RETURN) {\n      e.preventDefault();\n    }\n  },\n\n  /**\n   * Attempt to insert composed characters into the document.\n   *\n   * If we are still in a composition session, do nothing. Otherwise, insert\n   * the characters into the document and terminate the composition session.\n   *\n   * If no characters were composed -- for instance, the user\n   * deleted all composed characters and committed nothing new --\n   * force a re-render. We also re-render when the composition occurs\n   * at the beginning of a leaf, to ensure that if the browser has\n   * created a new text node for the composition, we will discard it.\n   *\n   * Resetting innerHTML will move focus to the beginning of the editor,\n   * so we update to force it back to the correct place.\n   */\n  resolveComposition: function resolveComposition(editor) {\n    if (stillComposing) {\n      return;\n    }\n\n    resolved = true;\n    var composedChars = textInputData;\n    textInputData = '';\n\n    var editorState = EditorState.set(editor._latestEditorState, {\n      inCompositionMode: false\n    });\n\n    var currentStyle = editorState.getCurrentInlineStyle();\n    var entityKey = getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection());\n\n    var mustReset = !composedChars || isSelectionAtLeafStart(editorState) || currentStyle.size > 0 || entityKey !== null;\n\n    if (mustReset) {\n      editor.restoreEditorDOM();\n    }\n\n    editor.exitCurrentMode();\n\n    if (composedChars) {\n      // If characters have been composed, re-rendering with the update\n      // is sufficient to reset the editor.\n      var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), composedChars, currentStyle, entityKey);\n      editor.update(EditorState.push(editorState, contentState, 'insert-characters'));\n      return;\n    }\n\n    if (mustReset) {\n      editor.update(EditorState.set(editorState, {\n        nativelyRenderedContent: null,\n        forceSelection: true\n      }));\n    }\n  }\n};\n\nmodule.exports = DraftEditorCompositionHandler;"]},"metadata":{},"sourceType":"script"}